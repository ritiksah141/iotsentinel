#!/usr/bin/env python3
"""
Vulnerability Synchronization Manager for IoTSentinel

Orchestrates daily CVE synchronization from NVD:
1. Extract unique vendors from devices
2. Fetch CVEs from NVD for each vendor
3. Match CVEs to devices
4. Update database with vulnerabilities
"""

import logging
import sqlite3
from typing import Dict, Any, List, Optional
from datetime import datetime
import time

logger = logging.getLogger(__name__)


class VulnerabilitySync:
    """
    Manages synchronization of vulnerability data from NVD.

    Coordinates NVD API client and CVE matcher for automated vulnerability detection.
    """

    def __init__(
        self,
        db_path: str = 'data/iot_monitor.db',
        nvd_api_key: Optional[str] = None,
        iot_keywords: Optional[List[str]] = None
    ):
        """
        Initialize vulnerability sync manager.

        Args:
            db_path: Path to database
            nvd_api_key: NVD API key (optional)
            iot_keywords: IoT keywords for CVE search
        """
        self.db_path = db_path
        self.nvd_api_key = nvd_api_key
        self.iot_keywords = iot_keywords or ['IoT', 'router', 'camera', 'smart', 'embedded']

        # Import dependencies
        try:
            from utils.nvd_api_client import get_nvd_client
            from utils.cve_matcher import get_cve_matcher

            self.nvd_client = get_nvd_client(api_key=nvd_api_key)
            self.cve_matcher = get_cve_matcher(db_path=db_path)

        except ImportError as e:
            logger.error(f"Failed to import dependencies: {e}")
            raise

        logger.info("Vulnerability sync manager initialized")

    def get_unique_vendors(self) -> List[str]:
        """
        Extract unique vendors from devices in database.

        Returns:
            List of unique vendor names
        """
        try:
            conn = self.db_manager.conn
            cursor = conn.cursor()

            # Get vendors from both vendor and manufacturer columns
            cursor.execute('''
                SELECT DISTINCT
                    CASE
                        WHEN vendor IS NOT NULL AND vendor != '' THEN vendor
                        WHEN manufacturer IS NOT NULL AND manufacturer != '' THEN manufacturer
                        ELSE NULL
                    END AS vendor_name
                FROM devices
                WHERE vendor_name IS NOT NULL
            ''')

            vendors = [row[0] for row in cursor.fetchall()]

            # Clean and normalize vendor names
            vendors = [v.strip() for v in vendors if v and v.strip()]
            vendors = list(set(vendors))  # Remove duplicates

            logger.info(f"Found {len(vendors)} unique vendors: {vendors}")
            return vendors

        except Exception as e:
            logger.error(f"Error getting unique vendors: {e}")
            return []

    def sync_vulnerabilities(
        self,
        vendors: Optional[List[str]] = None,
        max_cves_per_vendor: int = 100
    ) -> Dict[str, Any]:
        """
        Synchronize vulnerabilities from NVD.

        Args:
            vendors: List of vendors to sync (None = auto-detect from devices)
            max_cves_per_vendor: Maximum CVEs to fetch per vendor

        Returns:
            Dictionary with sync statistics
        """
        start_time = time.time()

        logger.info("Starting vulnerability synchronization")

        stats = {
            'sync_started': datetime.now().isoformat(),
            'vendors_processed': 0,
            'cves_fetched': 0,
            'devices_scanned': 0,
            'matches_found': 0,
            'high_severity_count': 0,
            'critical_severity_count': 0,
            'errors': []
        }

        try:
            # Get vendors if not provided
            if vendors is None:
                vendors = self.get_unique_vendors()

            if not vendors:
                logger.warning("No vendors found, skipping vendor-specific sync")

            all_cves = []

            # Fetch CVEs for each vendor
            for vendor in vendors:
                try:
                    logger.info(f"Fetching CVEs for vendor: {vendor}")

                    cves = self.nvd_client.fetch_cves_for_vendor(
                        vendor=vendor,
                        max_results=max_cves_per_vendor
                    )

                    if cves:
                        all_cves.extend(cves)
                        logger.info(f"Found {len(cves)} CVEs for {vendor}")

                    stats['vendors_processed'] += 1

                except Exception as e:
                    error_msg = f"Error fetching CVEs for {vendor}: {e}"
                    logger.error(error_msg)
                    stats['errors'].append(error_msg)

            # Also fetch general IoT CVEs
            try:
                logger.info(f"Fetching general IoT CVEs with keywords: {self.iot_keywords}")

                iot_cves = self.nvd_client.search_iot_cves(
                    keywords=self.iot_keywords,
                    max_results=200
                )

                # Merge with vendor CVEs (avoiding duplicates)
                existing_cve_ids = {cve['cve_id'] for cve in all_cves}
                for cve in iot_cves:
                    if cve['cve_id'] not in existing_cve_ids:
                        all_cves.append(cve)

                logger.info(f"Found {len(iot_cves)} general IoT CVEs")

            except Exception as e:
                error_msg = f"Error fetching IoT CVEs: {e}"
                logger.error(error_msg)
                stats['errors'].append(error_msg)

            stats['cves_fetched'] = len(all_cves)

            if not all_cves:
                logger.warning("No CVEs fetched, sync complete")
                stats['sync_completed'] = datetime.now().isoformat()
                stats['duration_seconds'] = time.time() - start_time
                return stats

            # Remove duplicates
            unique_cves = {}
            for cve in all_cves:
                cve_id = cve['cve_id']
                if cve_id not in unique_cves:
                    unique_cves[cve_id] = cve

            all_cves = list(unique_cves.values())
            logger.info(f"Total unique CVEs: {len(all_cves)}")

            # Match CVEs to devices
            logger.info("Matching CVEs to devices...")

            matches = self.cve_matcher.find_vulnerable_devices(all_cves)
            stats['matches_found'] = len(matches)

            # Count severity levels
            for match in matches:
                severity = match.get('severity', '').lower()
                if severity == 'critical':
                    stats['critical_severity_count'] += 1
                elif severity == 'high':
                    stats['high_severity_count'] += 1

            # Save matches to database
            if matches:
                saved_count = self.cve_matcher.save_matches_to_db(matches)
                logger.info(f"Saved {saved_count} vulnerability matches to database")

            # Update IoT vulnerabilities table
            self._update_iot_vulnerabilities_table(all_cves)

            stats['sync_completed'] = datetime.now().isoformat()
            stats['duration_seconds'] = round(time.time() - start_time, 2)

            logger.info(
                f"Vulnerability sync complete: {stats['cves_fetched']} CVEs, "
                f"{stats['matches_found']} matches in {stats['duration_seconds']}s"
            )

            return stats

        except Exception as e:
            error_msg = f"Error during vulnerability sync: {e}"
            logger.error(error_msg)
            stats['errors'].append(error_msg)
            stats['sync_completed'] = datetime.now().isoformat()
            stats['duration_seconds'] = time.time() - start_time
            return stats

    def _update_iot_vulnerabilities_table(self, cves: List[Dict[str, Any]]):
        """
        Update the iot_vulnerabilities table with CVE data.

        Args:
            cves: List of CVE dictionaries
        """
        try:
            conn = self.db_manager.conn
            cursor = conn.cursor()

            for cve in cves:
                # Check if CVE already exists
                cursor.execute(
                    "SELECT COUNT(*) FROM iot_vulnerabilities WHERE cve_id = ?",
                    (cve['cve_id'],)
                )

                if cursor.fetchone()[0] > 0:
                    # Update existing
                    cursor.execute('''
                        UPDATE iot_vulnerabilities
                        SET description = ?, severity = ?, cvss_score = ?,
                            published_date = ?, last_modified = ?
                        WHERE cve_id = ?
                    ''', (
                        cve['description'],
                        cve['severity'],
                        cve['cvss_score'],
                        cve.get('published', ''),
                        cve.get('last_modified', ''),
                        cve['cve_id']
                    ))
                else:
                    # Insert new - need to extract affected_vendors and affected_devices from CPE
                    affected_vendors = set()
                    affected_devices = set()

                    for cpe_string in cve.get('cpe_list', []):
                        cpe = self.cve_matcher.parse_cpe(cpe_string)
                        if cpe:
                            if cpe['vendor']:
                                affected_vendors.add(cpe['vendor'])
                            if cpe['product']:
                                affected_devices.add(cpe['product'])

                    cursor.execute('''
                        INSERT INTO iot_vulnerabilities
                        (cve_id, description, severity, cvss_score, affected_vendors,
                         affected_devices, published_date, last_modified)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        cve['cve_id'],
                        cve['description'],
                        cve['severity'],
                        cve['cvss_score'],
                        ', '.join(affected_vendors),
                        ', '.join(affected_devices),
                        cve.get('published', ''),
                        cve.get('last_modified', '')
                    ))

            conn.commit()

            logger.info(f"Updated iot_vulnerabilities table with {len(cves)} CVEs")

        except Exception as e:
            logger.error(f"Error updating iot_vulnerabilities table: {e}")

    def get_sync_stats(self) -> Dict[str, Any]:
        """
        Get statistics about vulnerability data in database.

        Returns:
            Dictionary with statistics
        """
        try:
            conn = self.db_manager.conn
            cursor = conn.cursor()

            # Total CVEs in database
            cursor.execute("SELECT COUNT(*) FROM iot_vulnerabilities")
            total_cves = cursor.fetchone()[0]

            # CVEs by severity
            cursor.execute('''
                SELECT severity, COUNT(*)
                FROM iot_vulnerabilities
                GROUP BY severity
            ''')
            by_severity = dict(cursor.fetchall())

            # Total device-CVE matches
            cursor.execute("SELECT COUNT(*) FROM device_vulnerabilities_detected")
            total_matches = cursor.fetchone()[0]

            # Devices with vulnerabilities
            cursor.execute('''
                SELECT COUNT(DISTINCT device_ip)
                FROM device_vulnerabilities_detected
            ''')
            vulnerable_devices = cursor.fetchone()[0]

            # Most vulnerable devices
            cursor.execute('''
                SELECT device_ip, COUNT(*) as vuln_count
                FROM device_vulnerabilities_detected
                GROUP BY device_ip
                ORDER BY vuln_count DESC
                LIMIT 5
            ''')
            most_vulnerable = [
                {'device_ip': row[0], 'vulnerability_count': row[1]}
                for row in cursor.fetchall()
            ]


            return {
                'total_cves': total_cves,
                'by_severity': by_severity,
                'total_device_matches': total_matches,
                'vulnerable_devices_count': vulnerable_devices,
                'most_vulnerable_devices': most_vulnerable
            }

        except Exception as e:
            logger.error(f"Error getting sync stats: {e}")
            return {}

    def cleanup_old_vulnerabilities(self, days: int = 90):
        """
        Remove vulnerability detections older than specified days.

        Args:
            days: Number of days to keep
        """
        try:
            conn = self.db_manager.conn
            cursor = conn.cursor()

            cutoff_date = datetime.now().timestamp() - (days * 24 * 60 * 60)
            cutoff_iso = datetime.fromtimestamp(cutoff_date).isoformat()

            cursor.execute(
                "DELETE FROM device_vulnerabilities_detected WHERE detected_at < ?",
                (cutoff_iso,)
            )

            deleted = cursor.rowcount
            conn.commit()

            if deleted > 0:
                logger.info(f"Cleaned up {deleted} old vulnerability detections")

        except Exception as e:
            logger.error(f"Error cleaning up old vulnerabilities: {e}")


# Global vulnerability sync instance
_vuln_sync = None


def get_vulnerability_sync(
    db_path: str = 'data/iot_monitor.db',
    nvd_api_key: Optional[str] = None
) -> VulnerabilitySync:
    """
    Get global vulnerability sync instance.

    Args:
        db_path: Path to database
        nvd_api_key: NVD API key (optional)

    Returns:
        VulnerabilitySync instance
    """
    global _vuln_sync
    if _vuln_sync is None:
        _vuln_sync = VulnerabilitySync(db_path=db_path, nvd_api_key=nvd_api_key)
    return _vuln_sync
